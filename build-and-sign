#!/bin/bash

# SystemVoiceMemos build/sign/release helper.
#
# Usage:
#   ./build-and-sign                # Debug build only
#   ./build-and-sign Release        # Release build only
#   ./build-and-sign Production     # Release + DMG + notarize/staple + Sparkle signature
#   ./build-and-sign Production --bump patch|minor|major
#   ./build-and-sign Production -p ./release-notes.txt
#   ./build-and-sign Production -m "Fixes and improvements"
#
# Notarization auth options (Production mode):
#   1) NOTARY_PROFILE=<keychain-profile-name>
#   2) APPLE_ID, APPLE_APP_SPECIFIC_PASSWORD, APPLE_TEAM_ID
#
# Sparkle signing key:
#   Defaults to ~/Downloads/sparkle_private_key
#   Override with SPARKLE_PRIVATE_KEY=/path/to/key

set -euo pipefail

APP_NAME="SystemVoiceMemos"
SCHEME="SystemVoiceMemos"
ARG_CONFIG=""
BUMP_KIND=""
RELEASE_NOTES_PATH=""
RELEASE_NOTES_MESSAGE=""
CONFIGURATION=""
PRODUCTION_MODE="false"

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

log_info() { echo -e "${GREEN}ℹ ${1}${NC}"; }
log_warn() { echo -e "${YELLOW}⚠ ${1}${NC}"; }
log_error() { echo -e "${RED}✗ ${1}${NC}"; }
log_success() { echo -e "${GREEN}✓ ${1}${NC}"; }

while [[ $# -gt 0 ]]; do
    case "$1" in
        Debug|debug|Release|release|Production|production)
            if [[ -n "$ARG_CONFIG" ]]; then
                log_error "Configuration specified more than once."
                exit 1
            fi
            ARG_CONFIG="$1"
            shift
            ;;
        --bump)
            if [[ $# -lt 2 ]]; then
                log_error "Missing value for --bump (patch|minor|major)."
                exit 1
            fi
            case "$2" in
                patch|minor|major)
                    BUMP_KIND="$2"
                    ;;
                *)
                    log_error "Invalid bump type: $2 (use patch|minor|major)."
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        -p)
            if [[ $# -lt 2 ]]; then
                log_error "Missing value for -p <release-notes-file>."
                exit 1
            fi
            RELEASE_NOTES_PATH="$2"
            shift 2
            ;;
        -m)
            if [[ $# -lt 2 ]]; then
                log_error "Missing value for -m <release-notes-message>."
                exit 1
            fi
            RELEASE_NOTES_MESSAGE="$2"
            shift 2
            ;;
        *)
            log_error "Unknown argument: $1"
            exit 1
            ;;
    esac
done

if [[ -n "$RELEASE_NOTES_PATH" && -n "$RELEASE_NOTES_MESSAGE" ]]; then
    log_error "Use either -p or -m for release notes, not both."
    exit 1
fi

if [[ -n "$RELEASE_NOTES_PATH" && ! -f "$RELEASE_NOTES_PATH" ]]; then
    log_error "Release notes file not found: $RELEASE_NOTES_PATH"
    exit 1
fi

ARG_CONFIG="${ARG_CONFIG:-Debug}"
case "$ARG_CONFIG" in
    Production|production)
        CONFIGURATION="Release"
        PRODUCTION_MODE="true"
        ;;
    Release|release)
        CONFIGURATION="Release"
        ;;
    Debug|debug)
        CONFIGURATION="Debug"
        ;;
    *)
        CONFIGURATION="$ARG_CONFIG"
        ;;
esac

DERIVED_DATA_PATH="/tmp/SystemVoiceMemos-build"
BUILD_OUTPUT_PATH="$DERIVED_DATA_PATH/Build/Products/$CONFIGURATION"
APP_PATH="$BUILD_OUTPUT_PATH/$APP_NAME.app"
DIST_DIR="$PWD/dist"
SPARKLE_PRIVATE_KEY="${SPARKLE_PRIVATE_KEY:-$HOME/Downloads/sparkle_private_key}"

require_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Missing required command: $1"
        exit 1
    fi
}

bump_versions() {
    local kind="$1"
    local pbxproj="SystemVoiceMemos.xcodeproj/project.pbxproj"

    if [[ ! -f "$pbxproj" ]]; then
        log_error "Project file not found: $pbxproj"
        exit 1
    fi

    local current major minor patch new_version
    current="$(grep 'MARKETING_VERSION = ' "$pbxproj" | head -n 1 | sed 's/.*= *//;s/ *;.*//' | tr -d '[:space:]')"

    if [[ -z "$current" ]]; then
        log_error "Could not read MARKETING_VERSION from $pbxproj."
        exit 1
    fi

    if [[ "$current" =~ ^([0-9]+)\.([0-9]+)(\.([0-9]+))?$ ]]; then
        major="${BASH_REMATCH[1]}"
        minor="${BASH_REMATCH[2]}"
        patch="${BASH_REMATCH[4]:-0}"
    else
        log_error "Current MARKETING_VERSION '$current' is not numeric semver (e.g. 1.2.3)."
        exit 1
    fi

    case "$kind" in
        major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
        minor)
            minor=$((minor + 1))
            patch=0
            ;;
        patch)
            patch=$((patch + 1))
            ;;
    esac

    new_version="${major}.${minor}.${patch}"

    log_info "Bumping MARKETING_VERSION: $current -> $new_version"
    sed -i '' "s/MARKETING_VERSION = ${current}/MARKETING_VERSION = ${new_version}/g" "$pbxproj"

    local build_num new_build_num
    build_num="$(grep 'CURRENT_PROJECT_VERSION = ' "$pbxproj" | head -n 1 | sed 's/.*= *//;s/ *;.*//' | tr -d '[:space:]')"
    new_build_num=$((build_num + 1))
    log_info "Incrementing CURRENT_PROJECT_VERSION: $build_num -> $new_build_num"
    sed -i '' "s/CURRENT_PROJECT_VERSION = ${build_num}/CURRENT_PROJECT_VERSION = ${new_build_num}/g" "$pbxproj"

    log_success "Version bump complete"
}

find_sparkle_sign_tool() {
    if command -v sign_update >/dev/null 2>&1; then
        command -v sign_update
        return
    fi

    local found
    # Check the build's derived data first, then Xcode's default location
    for search_dir in "$DERIVED_DATA_PATH" "$HOME/Library/Developer/Xcode/DerivedData"; do
        found="$(find "$search_dir" \
            -path "*/Sparkle/bin/sign_update" -not -path "*/old_dsa_scripts/*" \
            -type f 2>/dev/null | head -n 1 || true)"
        if [[ -n "$found" ]]; then
            echo "$found"
            return
        fi
    done
}

notarize_and_staple() {
    local file_path="$1"
    require_command xcrun

    if [[ -n "${NOTARY_PROFILE:-}" ]]; then
        log_info "Submitting for notarization with keychain profile: $NOTARY_PROFILE"
        xcrun notarytool submit "$file_path" --keychain-profile "$NOTARY_PROFILE" --wait
    elif [[ -n "${APPLE_ID:-}" && -n "${APPLE_APP_SPECIFIC_PASSWORD:-}" && -n "${APPLE_TEAM_ID:-}" ]]; then
        log_info "Submitting for notarization with Apple ID credentials"
        xcrun notarytool submit "$file_path" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait
    else
        log_warn "Notarization credentials not configured; skipping notarization and stapling."
        log_warn "Set NOTARY_PROFILE or (APPLE_ID + APPLE_APP_SPECIFIC_PASSWORD + APPLE_TEAM_ID) to enable."
        return 1
    fi

    log_info "Stapling notarization ticket"
    # NODE_TLS_REJECT_UNAUTHORIZED can break stapler's TLS trust evaluation
    unset NODE_TLS_REJECT_UNAUTHORIZED 2>/dev/null || true
    xcrun stapler staple "$file_path"
    xcrun stapler validate "$file_path"
    log_success "Notarization and stapling complete"
    return 0
}

extract_sparkle_signature() {
    local input="$1"
    local signature

    signature="$(echo "$input" | sed -n 's/.*sparkle:edSignature="\([^"]*\)".*/\1/p' | tail -n 1)"
    if [[ -n "$signature" ]]; then
        echo "$signature"
        return
    fi

    signature="$(echo "$input" | sed -n 's/.*edSignature=\(.*\)$/\1/p' | tail -n 1 | tr -d '" ')"
    if [[ -n "$signature" ]]; then
        echo "$signature"
        return
    fi

    signature="$(echo "$input" | awk '/^[A-Za-z0-9+/=]+$/ {print}' | tail -n 1)"
    echo "$signature"
}

html_escape() {
    local value="$1"
    value="${value//&/&amp;}"
    value="${value//</&lt;}"
    value="${value//>/&gt;}"
    value="${value//\"/&quot;}"
    value="${value//\'/&#39;}"
    echo "$value"
}

build_release_notes_html() {
    local raw="$1"
    local html=""
    local line=""
    local has_items="false"

    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^[[:space:]]*$ ]]; then
            continue
        fi
        if [[ "$has_items" != "true" ]]; then
            html="${html}        <ul>\n"
            has_items="true"
        fi
        html="${html}            <li>$(html_escape "$line")</li>\n"
    done <<< "$raw"

    if [[ "$has_items" == "true" ]]; then
        html="${html}        </ul>"
        printf '%b' "$html"
        return
    fi

    echo "        <p>No release notes provided.</p>"
}

if [[ -n "$BUMP_KIND" ]]; then
    bump_versions "$BUMP_KIND"
fi

log_info "Building $APP_NAME ($CONFIGURATION)..."

xcodebuild -scheme "$SCHEME" \
    -configuration "$CONFIGURATION" \
    -derivedDataPath "$DERIVED_DATA_PATH" \
    clean build \
    OTHER_CODE_SIGN_FLAGS="--timestamp" \
    CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO

if [[ ! -d "$APP_PATH" ]]; then
    log_error "Built app not found: $APP_PATH"
    exit 1
fi

log_success "Build completed: $APP_PATH"

# Re-sign embedded frameworks/helpers with Developer ID + timestamp
if [[ "$PRODUCTION_MODE" == "true" ]]; then
    SIGNING_IDENTITY="$(security find-identity -v -p codesigning | grep 'Developer ID Application' | head -n 1 | sed 's/.*"\(.*\)"/\1/')"
    if [[ -n "$SIGNING_IDENTITY" ]]; then
        log_info "Re-signing embedded binaries with: $SIGNING_IDENTITY"
        find "$APP_PATH/Contents/Frameworks" -type f \( -name "*.xpc" -o -name "*.app" -o -name "*.dylib" \) -prune -o \
            -type f -perm +111 -print | while read -r binary; do
            codesign --force --sign "$SIGNING_IDENTITY" --timestamp -o runtime "$binary" 2>/dev/null || true
        done
        # Sign XPC services, helper apps, and the framework bundle itself
        find "$APP_PATH/Contents/Frameworks" -name "*.xpc" -o -name "*.app" | while read -r bundle; do
            codesign --force --deep --sign "$SIGNING_IDENTITY" --timestamp -o runtime "$bundle" 2>/dev/null || true
        done
        find "$APP_PATH/Contents/Frameworks" -name "*.framework" | while read -r fw; do
            codesign --force --sign "$SIGNING_IDENTITY" --timestamp -o runtime "$fw" 2>/dev/null || true
        done
        # Re-sign the main app last
        codesign --force --sign "$SIGNING_IDENTITY" --timestamp -o runtime --entitlements <(codesign -d --entitlements - --xml "$APP_PATH" 2>/dev/null | sed '1d') "$APP_PATH" 2>/dev/null || true
        log_success "Re-signing complete"
    fi
fi

if [[ "$PRODUCTION_MODE" != "true" ]]; then
    log_info "Non-production mode complete."
    exit 0
fi

require_command create-dmg
mkdir -p "$DIST_DIR"

VERSION="$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$APP_PATH/Contents/Info.plist")"
DMG_NAME="${APP_NAME}-${VERSION}.dmg"
DMG_PATH="$DIST_DIR/$DMG_NAME"

log_info "Creating DMG with create-dmg"
create-dmg --overwrite --dmg-title "$APP_NAME" "$APP_PATH" "$DIST_DIR"

# create-dmg uses the app's display name; find whatever .dmg it created and rename
GENERATED_DMG="$(find "$DIST_DIR" -maxdepth 1 -name "*.dmg" -newer "$APP_PATH" | head -n 1)"
if [[ -z "$GENERATED_DMG" ]]; then
    # Fallback: find any .dmg containing the version
    GENERATED_DMG="$(find "$DIST_DIR" -maxdepth 1 -name "*${VERSION}*.dmg" | head -n 1)"
fi
if [[ -n "$GENERATED_DMG" && "$GENERATED_DMG" != "$DMG_PATH" ]]; then
    mv "$GENERATED_DMG" "$DMG_PATH"
fi

if [[ ! -f "$DMG_PATH" ]]; then
    log_error "DMG not found at expected path: $DMG_PATH"
    exit 1
fi
log_success "DMG created: $DMG_PATH"

NOTARIZED="false"
if notarize_and_staple "$DMG_PATH"; then
    NOTARIZED="true"
fi

if [[ ! -f "$SPARKLE_PRIVATE_KEY" ]]; then
    log_error "Sparkle private key not found: $SPARKLE_PRIVATE_KEY"
    exit 1
fi

SIGN_TOOL="$(find_sparkle_sign_tool)"
if [[ -z "${SIGN_TOOL:-}" ]]; then
    log_error "Could not find Sparkle sign tool (sign_update)."
    log_error "Install Sparkle tools or expose sign_update on PATH."
    exit 1
fi

log_info "Signing DMG for Sparkle using: $SIGN_TOOL"
SIGN_OUTPUT="$("$SIGN_TOOL" "$DMG_PATH" --ed-key-file "$SPARKLE_PRIVATE_KEY" 2>&1)"
SPARKLE_SIGNATURE="$(extract_sparkle_signature "$SIGN_OUTPUT")"

if [[ -z "$SPARKLE_SIGNATURE" ]]; then
    log_error "Failed to parse Sparkle signature from sign_update output."
    echo "$SIGN_OUTPUT"
    exit 1
fi

FILE_SIZE="$(stat -f%z "$DMG_PATH")"
PUB_DATE="$(date -Ru)"
DOWNLOAD_URL="https://github.com/aramb-dev/SystemVoiceMemos/releases/download/v${VERSION}/${DMG_NAME}"
APPCAST_SNIPPET_PATH="$DIST_DIR/appcast-item-${VERSION}.xml"
RELEASE_NOTES_RAW=""

if [[ -n "$RELEASE_NOTES_PATH" ]]; then
    RELEASE_NOTES_RAW="$(cat "$RELEASE_NOTES_PATH")"
elif [[ -n "$RELEASE_NOTES_MESSAGE" ]]; then
    RELEASE_NOTES_RAW="$RELEASE_NOTES_MESSAGE"
fi

RELEASE_NOTES_HTML="$(build_release_notes_html "$RELEASE_NOTES_RAW")"

cat > "$APPCAST_SNIPPET_PATH" <<EOF
<item>
    <title>Version ${VERSION}</title>
    <sparkle:version>${VERSION}</sparkle:version>
    <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
    <description><![CDATA[
        <h2>What's New in ${VERSION}</h2>
${RELEASE_NOTES_HTML}
    ]]></description>
    <pubDate>${PUB_DATE}</pubDate>
    <enclosure
        url="${DOWNLOAD_URL}"
        sparkle:version="${VERSION}"
        sparkle:shortVersionString="${VERSION}"
        length="${FILE_SIZE}"
        type="application/octet-stream"
        sparkle:edSignature="${SPARKLE_SIGNATURE}" />
</item>
EOF

log_success "Sparkle signature generated."
echo ""
log_success "=== Release Summary ==="
log_info "Version:    $VERSION"
log_info "Artifact:   $DMG_PATH"
log_info "Size:       $FILE_SIZE bytes"
log_info "Signature:  $SPARKLE_SIGNATURE"
if [[ "$NOTARIZED" == "true" ]]; then
    log_success "Notarized:  Yes (stapled)"
else
    log_warn "Notarized:  No (set NOTARY_PROFILE to enable)"
fi
log_info "Appcast:    $APPCAST_SNIPPET_PATH"
echo ""
log_info "Next steps:"
log_info "  1. Copy appcast snippet into appcast.xml"
log_info "  2. gh release create v${VERSION} \"$DMG_PATH\" -t \"v${VERSION}\" -n \"Release notes\""
log_info "  3. git push"
